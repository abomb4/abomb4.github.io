---
layout: post
title:  "学习记录"
categories: Personal
date: +0800 2020-07-21 12:00:00
tag: personal
---

* content
{:toc}

# 2020-07-21
--------------
> java 分为几个内存区域？

- 堆
- 方法区
- 栈
- 本地方法栈
- 程序计数器 pc
- 直接内存
其中堆和方法区是线程间共享的，栈、本地方法栈、pc 是x线程独立的。
严格来说直接内存不属于 jvm 内存区域定义，但它会被用到，主要是 java.nio.buffer.DirectBypteBuffer。
这块内存由操作系统管理，也有可能发生oom。

> 每个内存区域做什么？

堆：
    是几乎所有对象的存放地点，由所有线程共享。这块内存是垃圾回收器主要处理的内存。
    有个细节是 TLAB 机制，是每个线程在堆区域有自己的一块空间用于快速创建对象。

栈：
    栈内存是线程私有内存，与线程有相同的生命周期，描述 java 方法执行线程的内存模型。
    栈区存放栈帧；栈帧是每个方法进入时都会创建的数据结构，
    包含：局部变量表、操作数栈、动态链接、程序出口（后面会讲）；
    局部变量表存的是基本类型数据，long 和 double 占用 2 个位置，其余的占 1 个位置，
    规定如此但虚拟机可以自行实现细节。

方法区：
    jvm 定义这块区域存储一些静态内容，包括类型、常量、静态变量、JIT 代码缓存等。
    实现层面，这东西在 jdk7 及之前被 hotspot 实现为‘永久代’，后来因容易引起 oom，
    现在在‘本地内存’中实现‘元空间’。

程序计数器：
    程序计数器存储当前字节码的‘行号’，方便上下文切换时找到当前线程正在运行的程序。
    该区域不存在 oom。

本地方法栈：
    是调用原生程序时原生程序使用的栈区。据说 hotspot 将 java 栈和本地方法栈合二为一。

直接内存：
    直接内存是直接使用操作系统内存的区域，一般不受大小限制，但内存不足时也会 oom。
    主要应用为 java.nio.buffer.DirectByteBuffer 。

> OOM 有几种情况：

jdk7 之前永久代溢出；堆 Xmx；系统内存满

> Leetcode 11 盛水最多的容器

使用‘双指针法’解决，是看了答案的。
核心在于，不断消除不可能成为最大值的状态，跳过之。
