---
layout: post
title:  "学习记录"
categories: Personal
date: +0800 2020-07-21 12:00:00
tag: personal
---

* content
{:toc}

# 2020-07-21
----------------------------------------------------------------------
> java 分为几个内存区域？

- 堆
- 方法区
- 栈
- 本地方法栈
- 程序计数器 pc
- 直接内存
其中堆和方法区是线程间共享的，栈、本地方法栈、pc 是x线程独立的。
严格来说直接内存不属于 jvm 内存区域定义，但它会被用到，主要是 java.nio.buffer.DirectBypteBuffer。
这块内存由操作系统管理，也有可能发生oom。

> 每个内存区域做什么？

堆：
    是几乎所有对象的存放地点，由所有线程共享。这块内存是垃圾回收器主要处理的内存。
    有个细节是 TLAB 机制，是每个线程在堆区域有自己的一块空间用于快速创建对象。

栈：
    栈内存是线程私有内存，与线程有相同的生命周期，描述 java 方法执行线程的内存模型。
    栈区存放栈帧；栈帧是每个方法进入时都会创建的数据结构，
    包含：局部变量表、操作数栈、动态链接、程序出口（后面会讲）；
    局部变量表存的是基本类型数据，long 和 double 占用 2 个位置，其余的占 1 个位置，
    规定如此但虚拟机可以自行实现细节。

方法区：
    jvm 定义这块区域存储一些静态内容，包括类型、常量、静态变量、JIT 代码缓存等。
    实现层面，这东西在 jdk7 及之前被 hotspot 实现为‘永久代’，后来因容易引起 oom，
    现在在‘本地内存’中实现‘元空间’。

程序计数器：
    程序计数器存储当前字节码的‘行号’，方便上下文切换时找到当前线程正在运行的程序。
    该区域不存在 oom。

本地方法栈：
    是调用原生程序时原生程序使用的栈区。据说 hotspot 将 java 栈和本地方法栈合二为一。

直接内存：
    直接内存是直接使用操作系统内存的区域，一般不受大小限制，但内存不足时也会 oom。
    主要应用为 java.nio.buffer.DirectByteBuffer 。

> OOM 有几种情况：

jdk7 之前永久代溢出；堆 Xmx；系统内存满

> Leetcode 11 盛水最多的容器

使用‘双指针法’解决，是看了答案的。
核心在于，不断消除不可能成为最大值的状态，跳过之。

# 2020-07-22
----------------------------------------------------------------------
> 对象创建的大致流程描述一下

执行 new 语句时，在虚拟机中也对应一个 new 指令，一般还对应一个 invokespecial 指令用于执行构造函数。
一个 new 指令的大致流程：
1. 检查参数是否在常量池中能定位到一个类的符号引用
2. 检查这个符号引用代表的类有没有加载、解析、初始化
3. 类型信息中可得知对象占用空间大小，开始划分内存空间
4. 初始化零值
5. 对象头设置
  - 对象头包含 Mark Word 和类型指针两部分
  - Mark Word 是一种动态数据结构，根据标志位存储不同内容,未锁定时： hash code、分代年龄、锁标志位、固定 0
  - 类型指针指向类型元数据，确定自己是哪个类

6. invokespecial 会执行构造函数，此时在 java 语言中才视为一个对象开始创建。

> 有哪几种死活判定算法
- 引用计数
- 可达性分析

> 说明一下每种垃圾判定算法的定义和特点
引用计数：

  在对象中存储其被引用的次数，变为 0 时可以回收。但无法处理循环引用情况。

可达性分析：

  这种算法目前广泛采用，根据 GC Root 对象一层层寻找引用关系，走过的路径称为引用链；
  如果某个对象没有与任何引用链相连，则该对象视为可回收。

可达性分析算法的 GC Roots 会固定选取以下对象：
- 栈中引用的对象
- 方法区中类的 static 引用对象
- 方法区中常量引用的对象，如 StringTable 中的引用
- JNI （原生接口）中引入的对象
- JVM 内部引用，如基本数据类型的 Class、常驻对象（NPE、OOM）、系统类加载器
- 所有 synchronized 持有的对象
- JMXBean、JVMTI中注册的回调、本地代码缓存

支持部分回收的回收器，可能会将与回收区域有关的对象加入 GC Roots

> Java 中有几种引用，各有什么特点和场景
JDK 1.2 之后，引用扩展为强引用、软引用、弱引用、虚引用四种，引用强度逐渐下降。

- 强引用：最传统常用的引用，不会回收被引用对象
- 软引用：当内存不足发生溢出时会被回收的对象。
  多用于创建缓存，例如多标签图像编辑器中，可以用软引用缓存某标签的图像，
  内存足够时迅速切换，不够时会被回收，下次重新读取。
- 弱引用：下一次 GC 就回收掉的引用。
  会应用引用队列，方便后续清除工作；典型应用包括 ThreadLocal（以 Thread 对象为 key 的 map，作为 key 的 Thread 被回收后，该线程对应的 value 也被回收）
- 虚引用：唯一目的只有在对象被回收时虚引用会进入引用队列。
  据说可用于实现精细的内存控制，在微小内存的环境使用

> 方法区的回收？
主要回收废弃的常量和不再使用的类型。

判断不再使用的类型需要满足：
1. 该类所有实例都被回收，也包含了其各种子类
2. 该类的类加载器已经回收，一般只有 osgi、jsp、tomcat 之类的专门涉及的类加载机制可以满足
3. 该类的 Class 对象没有被引用

> Leetcode 15 三数之和

我的思路：总之先排序，然后三个指针，ijk，i从头到尾，j 每次从头到尾，k每次从尾部到头，时间复杂度 O(n^2)
